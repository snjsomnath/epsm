name: Deploy to Production

# NOTE: This workflow uses a SELF-HOSTED runner on the VM
# The runner must be set up first - see SELF_HOSTED_RUNNER_SETUP.md
# 
# This workflow runs directly on the VM, so no SSH or firewall issues!

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'

  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    runs-on: self-hosted  # Uses runner on VM, not GitHub-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy application
        run: |
          cd /opt/epsm
          
          # Pull latest code
          echo "üì• Pulling latest code..."
          git pull origin main
          
          # Load environment variables
          echo "üîß Loading environment variables..."
          set -a
          source .env.production
          set +a
          
          # Rebuild and deploy
          echo "üöÄ Rebuilding and deploying services..."
          docker-compose -f docker-compose.prod.yml build --no-cache
          docker-compose -f docker-compose.prod.yml up -d
          
          # Wait for services
          echo "‚è≥ Waiting for services to start..."
          sleep 30
          
          # Run migrations
          echo "üìä Running database migrations..."
          docker-compose -f docker-compose.prod.yml exec -T backend python manage.py migrate --noinput
          
          # Collect static files
          echo "üìÅ Collecting static files..."
          docker-compose -f docker-compose.prod.yml exec -T backend python manage.py collectstatic --noinput
          
          # Clean up
          echo "üßπ Cleaning up..."
          docker system prune -f
          
          # Show status
          echo "‚úÖ Deployment complete!"
          docker-compose -f docker-compose.prod.yml ps
