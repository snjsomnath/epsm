# Production Docker Compose Configuration
version: '3.8'

services:
  # PostgreSQL Database
  database:
    build:
      context: ./database
      dockerfile: Dockerfile
    container_name: epsm_database_prod
    environment:
      POSTGRES_DB: epsm_db
      POSTGRES_USER: epsm_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_MULTIPLE_DATABASES: epsm_db,epsm_materials
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
      - ./database/exports:/docker-entrypoint-initdb.d/exports:ro
    ports:
      - "127.0.0.1:5432:5432"  # Only localhost access
    networks:
      - epsm_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U epsm_user -d epsm_db"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    restart: unless-stopped

  # Django Backend
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
    container_name: epsm_backend_prod
    environment:
      - DEBUG=False
      - DB_NAME=epsm_db
      - DB_USER=epsm_user
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_HOST=database
      - DB_PORT=5432
      - MATERIALS_DB_NAME=epsm_materials
      - MATERIALS_DB_USER=epsm_user
      - MATERIALS_DB_PASSWORD=${DB_PASSWORD}
      - MATERIALS_DB_HOST=database
      - MATERIALS_DB_PORT=5432
      - RESULTS_DB_NAME=${RESULTS_DB_NAME:-epsm_db}
      - RESULTS_DB_USER=${RESULTS_DB_USER:-epsm_user}
      - RESULTS_DB_PASSWORD=${RESULTS_DB_PASSWORD:-epsm_secure_password}
      - RESULTS_DB_HOST=${RESULTS_DB_HOST:-database}
      - RESULTS_DB_PORT=${RESULTS_DB_PORT:-5432}
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
      - DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE:-config.settings.production}
      - ALLOWED_HOSTS=${ALLOWED_HOSTS:-epsm.chalmers.se,epsm.ita.chalmers.se,localhost,backend}
      - ENERGYPLUS_DOCKER_IMAGE=nrel/energyplus:23.2.0
      - SIMULATION_TIMEOUT=600
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/0
      - SAML_IDP_METADATA_URL=${SAML_IDP_METADATA_URL:-}
    volumes:
      - simulation_files_prod:/app/media/simulation_files
      - simulation_results_prod:/app/media/simulation_results
      - static_files:/app/staticfiles
      - /var/run/docker.sock:/var/run/docker.sock
      - /opt:/host-opt:ro  # Read-only bind mount of host /opt for disk monitoring
    expose:
      - "8000"
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - epsm_network
    restart: unless-stopped

  # React Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
      args:
        VITE_API_BASE_URL: ${VITE_API_BASE_URL:-https://epsm.chalmers.se}
        VITE_WS_URL: ${VITE_WS_URL:-wss://epsm.chalmers.se/ws}
    container_name: epsm_frontend_prod
    expose:
      - "80"
    depends_on:
      - backend
    networks:
      - epsm_network
    restart: unless-stopped

  # Nginx Reverse Proxy
  nginx:
    build:
      context: ./.docker/nginx
      dockerfile: Dockerfile
    container_name: epsm_nginx_prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./.docker/nginx/ssl:/etc/nginx/ssl:ro  # SSL certificates
      - static_files:/var/www/static:ro
      - simulation_files_prod:/app/media:ro  # Media files
    depends_on:
      - frontend
      - backend
    networks:
      - epsm_network
    restart: unless-stopped

  # Redis for caching and sessions
  redis:
    image: redis:7-alpine
    container_name: epsm_redis_prod
    volumes:
      - redis_data_prod:/data
    networks:
      - epsm_network
    command: sh -c "if [ -n \"${REDIS_PASSWORD}\" ]; then redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}; else redis-server --appendonly yes; fi"
    restart: unless-stopped

  # Celery Worker for async task processing
  celery_worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
    container_name: epsm_celery_worker_prod
    command: celery -A config worker --loglevel=info --concurrency=4
    environment:
      - DEBUG=False
      - DB_NAME=epsm_db
      - DB_USER=epsm_user
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_HOST=database
      - DB_PORT=5432
      - MATERIALS_DB_NAME=epsm_materials
      - MATERIALS_DB_USER=epsm_user
      - MATERIALS_DB_PASSWORD=${DB_PASSWORD}
      - MATERIALS_DB_HOST=database
      - MATERIALS_DB_PORT=5432
      - RESULTS_DB_NAME=${RESULTS_DB_NAME:-epsm_db}
      - RESULTS_DB_USER=${RESULTS_DB_USER:-epsm_user}
      - RESULTS_DB_PASSWORD=${RESULTS_DB_PASSWORD:-epsm_secure_password}
      - RESULTS_DB_HOST=${RESULTS_DB_HOST:-database}
      - RESULTS_DB_PORT=${RESULTS_DB_PORT:-5432}
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
      - DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE:-config.settings.production}
      - ENERGYPLUS_DOCKER_IMAGE=nrel/energyplus:23.2.0
      - SIMULATION_TIMEOUT=600
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/0
    volumes:
      - simulation_files_prod:/app/media/simulation_files
      - simulation_results_prod:/app/media/simulation_results
      - /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - epsm_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "celery", "-A", "config", "inspect", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Celery Beat for periodic tasks
  celery_beat:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
    container_name: epsm_celery_beat_prod
    command: celery -A config beat --loglevel=info
    environment:
      - DEBUG=False
      - DB_NAME=epsm_db
      - DB_USER=epsm_user
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_HOST=database
      - DB_PORT=5432
      - MATERIALS_DB_NAME=epsm_materials
      - MATERIALS_DB_USER=epsm_user
      - MATERIALS_DB_PASSWORD=${DB_PASSWORD}
      - MATERIALS_DB_HOST=database
      - MATERIALS_DB_PORT=5432
      - RESULTS_DB_NAME=${RESULTS_DB_NAME:-epsm_db}
      - RESULTS_DB_USER=${RESULTS_DB_USER:-epsm_user}
      - RESULTS_DB_PASSWORD=${RESULTS_DB_PASSWORD:-epsm_secure_password}
      - RESULTS_DB_HOST=${RESULTS_DB_HOST:-database}
      - RESULTS_DB_PORT=${RESULTS_DB_PORT:-5432}
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
      - DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE:-config.settings.production}
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/0
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - epsm_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "pgrep", "-f", "celery.*beat"]
      interval: 30s
      timeout: 10s
      retries: 3

  # EnergyPlus service to ensure image is always available
  energyplus:
    image: nrel/energyplus:23.2.0
    container_name: epsm_energyplus_prod
    command: /bin/true  # Do nothing, just ensure image is available
    restart: "no"  # Only needed to pull the image
    networks:
      - epsm_network
    profiles:
      - tools  # Optional profile, can be started manually

  # Monitoring (optional)
  monitoring:
    image: prom/prometheus:latest
    container_name: epsm_monitoring_prod
    ports:
      - "127.0.0.1:9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    networks:
      - epsm_network
    restart: unless-stopped
    profiles:
      - monitoring

volumes:
  postgres_data_prod:
    driver: local
  simulation_files_prod:
    driver: local
  simulation_results_prod:
    driver: local
  static_files:
    driver: local
  redis_data_prod:
    driver: local
  prometheus_data:
    driver: local

networks:
  epsm_network:
    driver: bridge