{
  "docs": [
    {
      "path": "LICENSE.md",
      "url": "/LICENSE.md",
      "title": "License",
      "content": "MIT License Copyright c 2025 Sanjay Somanath Permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the Software to deal in the Software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the Software and to permit persons to whom the Software is furnished to do so subject to the following conditions The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software THE SOFTWARE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM DAMAGES OR OTHER LIABILITY WHETHER IN AN ACTION OF CONTRACT TORT OR OTHERWISE ARISING FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE"
    },
    {
      "path": "ARCHITECTURE.md",
      "url": "/ARCHITECTURE.md",
      "title": "Architecture",
      "content": "EPSM Architecture Documentation title Architecture layout default System Overview EPSM Energy Performance Simulation Manager is a microservices based web application for managing building energy simulations The system is built with modern technologies and follows best practices for scalability maintainability and deployment Technology Stack Frontend Framework React 18 with TypeScript Build Tool Vite 5 Styling Tailwind CSS UI Components Material UI MUI Charts Recharts Chart js State Management React Context API HTTP Client Axios Backend Framework Django 3 2 with Django REST Framework Language Python 3 11 Database PostgreSQL 15 Caching Redis 7 WebSockets Django Channels File Processing eppy EnergyPlus lxml Container Runtime Docker Infrastructure Containerization Docker Docker Compose Reverse Proxy Nginx Database PostgreSQL with custom initialization Caching Redis for sessions and caching Simulation Engine EnergyPlus containerized Architecture Patterns Microservices Architecture Data Flow Architecture Service Details Frontend Service React Responsibilities User interface rendering Client side routing State management API communication Real time updates via WebSocket Key Components API Integration REST API for CRUD operations WebSocket for real time simulation updates File upload download handling Authentication token management Backend Service Django Responsibilities REST API endpoints WebSocket handling Business logic Authentication authorization File processing Simulation orchestration App Structure Key Features Django REST Framework for API Django Channels for WebSocket PostgreSQL for data persistence Redis for caching and sessions Docker integration for EnergyPlus Database Service PostgreSQL Database Schema Data Relationships Users Projects 1 many Projects Scenarios 1 many Scenarios Simulation Runs 1 many Simulation Runs Results 1 many Security Architecture Authentication Authorization Security Measures Session based authentication CSRF protection Rate limiting Input validation SQL injection prevention XSS protection Secure headers SSL TLS encryption File Security Upload size limits File type validation Virus scanning planned Secure file storage Access control Performance Architecture Caching Strategy Caching Layers 1 Browser Cache Static assets CSS JS images 2 Nginx Cache API responses static files 3 Redis Cache Database queries session data 4 Database Cache Query optimization Scalability Horizontal scaling with Docker Swarm Kubernetes Database connection pooling Async task processing Load balancing Auto scaling policies Development Architecture Development Workflow Development Stack Docker Compose for local development Hot reloading for frontend and backend Database migrations Test automation Code quality checks Testing Strategy Deployment Architecture Container Strategy Production Configuration Multi stage Docker builds Environment specific configurations Health checks and monitoring Automated backups Log aggregation Security scanning Infrastructure Development Docker Compose Staging Docker Swarm Production Kubernetes recommended Database Managed PostgreSQL or container Storage Object storage for files Monitoring Prometheus Grafana Logging ELK stack Monitoring Observability Health Checks Application health endpoints Database connectivity Redis connectivity Container health status External dependencies Metrics Collection Application performance Database performance Container resource usage Business metrics User activity Logging Strategy Structured logging Centralized log collection Log retention policies Error tracking Audit trails Future Architecture Considerations Planned Improvements 1 Microservices Split Separate simulation service 2 Event Driven Architecture Message queues for async processing 3 API Gateway Centralized API management 4 Service Mesh Inter service communication 5 Serverless Functions For batch processing 6 Multi tenant Architecture SaaS deployment model Technology Roadmap GraphQL API alongside REST Machine learning integration Real time collaboration features Mobile application support Cloud native deployment"
    },
    {
      "path": "DOCS_IA.md",
      "url": "/DOCS_IA.md",
      "title": "Proposed Information Architecture for EPSM Docs",
      "content": "Proposed Information Architecture for EPSM Docs Goal Simplify navigation reduce clutter remove archive and provide a clear hierarchy and sidebar Top level sections sidebar order Home Getting Started Guides Development Deployment Results Database API Reference Architecture Scripts Utilities Contributing Project Legal Notes Remove archive entirely Move any useful archived content into Guides or append to a Changelog History section if needed Project README and README md are distinct keep PROJECT_README md under Project Legal or Home as a link Keep index page minimal with hero short description and primary quick links Migration plan 1 Create the new _sidebar md reflecting this IA 2 Replace heavy index content with concise landing page 3 Move or merge outdated archive content 4 Update _layouts default html to include the sidebar and a simplified header 5 Modernize assets css site css Acceptance criteria Sidebar shows hierarchical nav and appears on all pages Index is concise and links to major sections Archive folder removed"
    },
    {
      "path": "API.md",
      "url": "/API.md",
      "title": "API Documentation",
      "content": "EPSM API Documentation title API Documentation layout default This document describes the REST API endpoints available in the EPSM Energy Performance Simulation Manager backend Base URL Development http localhost 8000 Production https your domain com Authentication EPSM uses Django session based authentication with CSRF protection Login Response Logout Get Current User API Endpoints Health Check System Health Response System Resources Response File Management Parse IDF File Response Parse Weather File Simulation Management Create Simulation Response Run Simulation Response Get Simulation Status Response Get Simulation Results Response Database Operations Materials Get All Materials Response Create Material Update Material Delete Material Constructions Get All Constructions Create Construction Construction Sets Get All Construction Sets Create Construction Set File Downloads Download Simulation Results Returns a ZIP file containing all simulation output files Download Sample Files Returns sample IDF and EPW files for testing WebSocket API Real time updates are available via WebSocket connections Connection Simulation Updates System Status Updates Request Response Formats Standard Response Format Error Response Format HTTP Status Codes 200 OK Request successful 201 Created Resource created successfully 204 No Content Delete successful 400 Bad Request Invalid request data 401 Unauthorized Authentication required 403 Forbidden Permission denied 404 Not Found Resource not found 422 Unprocessable Entity Validation error 500 Internal Server Error Server error CSRF Protection For POST PUT DELETE requests include the CSRF token Rate Limiting API endpoints are rate limited to prevent abuse Authentication 5 requests per minute File uploads 10 requests per minute General API 100 requests per minute WebSocket 1000 messages per minute Testing the API Using curl Using Python requests Additional Resources Django REST Framework https www django rest framework org EnergyPlus https energyplus net WebSocket API https channels readthedocs io CSRF Protection https docs djangoproject com en 3 2 ref csrf"
    },
    {
      "path": "RESULTS_DB_SETUP.md",
      "url": "/RESULTS_DB_SETUP.md",
      "title": "Results DB Setup",
      "content": "Setting up a dedicated results Postgres database title Results DB Setup layout default This project can use a dedicated PostgreSQL database for simulation results time series A new database alias results_db is added to backend config settings py and the DB router will direct simulation result models to this database This document explains how to provision the DB locally or in Docker run migrations for the new DB and optionally migrate existing data Steps 1 Provision a Postgres instance reachable from the Django backend If using Docker Compose add a service named results_db or reuse the existing database service and expose another DB name Example snippet to add to docker compose yml adapt names credentials 2 Set environment variables locally or in your env to point Django at the new DB Keys introduced in settings py RESULTS_DB_NAME default epsm_results RESULTS_DB_USER default epsm_results_user RESULTS_DB_PASSWORD RESULTS_DB_HOST default database RESULTS_DB_PORT default 5432 3 Run migrations specifically to the results DB From the repository root This will create the tables for the simulation app models that have been routed to results_db 4 Optional Migrate existing data from default to results_db if you already have results in the default DB Two common approaches Using pg_dump pg_restore or pg_dump data only to export relevant tables from the default DB and import them into the new results DB This requires network access and careful handling of sequences and constraints Using manage py dumpdata and loaddata Note The loaddata approach may require editing PKs or relationships if the Simulation objects remain in default while SimulationResult objects are moved to results_db Because relations across databases are not supported you might need to keep Simulation in default and only move result rows that reference simulation_id values that already exist in the results_db or change the FK to a plain UUID and remove cross db FK constraints Plan carefully and test on a staging DB first 5 Update docker compose and deployment docs ensure the results_db service is created and env vars are set for production Quick note scripts start sh automation The development scripts start sh can now help with provisioning and initializing the results DB in Docker setups When run in the default development environment it will Wait for the primary database to be ready and then attempt to create the epsm_results database and epsm_results_user role if they are missing idempotent Run migrations for the results_db when the RESULTS_DB_ environment variables are set the script exports these for the migration command in the development flow Use scripts start sh for a quick development workflow that includes results DB setup or follow the manual steps above for custom provisioning 6 Confirm behavior Start the backend and run a sample simulation Verify that new rows for simulation_results simulation_zones and simulation_energy_uses appear in the results_db Postgres instance Verify queries via Django shell Notes and caveats Cross database ForeignKey relations are not supported by Django The router is configured to route SimulationResult and its dependent models to results_db but the Simulation model remains in the default DB That means you cannot rely on database level FK enforcement across DBs The current design keeps simulation in default while placing results in results_db This works but be aware of referential integrity limitations If you need strong referential integrity consider moving the Simulation model itself into results_db more invasive or store simulation_id as a plain UUID on the result rows instead of a ForeignKey Tests should be updated to create and tear down data in the results_db when exercising results functionality If you d like I can also Add a docker compose service and environment variable examples to the repo Create migration files or tweak models to use a UUID field instead of FK for cross db references to avoid cross db FK restrictions Ask which of these you d like me to implement next"
    },
    {
      "path": "SCRIPTS.md",
      "url": "/SCRIPTS.md",
      "title": "Scripts",
      "content": "EPSM Scripts Documentation title Scripts layout default This document describes the clean organized script structure for the EPSM project Script Overview The scripts directory contains 8 essential scripts with clear distinct purposes Development Scripts start sh Purpose Start the complete EPSM development environment Starts all Docker services backend frontend database redis Runs database migrations Creates default superuser if needed Shows service status and useful URLs Usage scripts start sh stop sh Purpose Stop all EPSM services Stops all Docker containers Clean shutdown of the development environment Usage scripts stop sh status sh Purpose Check the status of all EPSM services Shows Docker service status Tests frontend and backend connectivity Checks database accessibility Displays useful URLs and credentials Usage scripts status sh test sh Purpose Run all tests for the EPSM application Sets up test environment Runs backend Django tests Runs frontend tests Includes integration test placeholder Usage scripts test sh Database Management Scripts backup sh Purpose Create backups of PostgreSQL databases Backs up main database and materials database Creates compressed archives Supports both development and production environments Optional S3 upload capability Automatic cleanup of old backups 30 days Usage Development scripts backup sh Production scripts backup sh prod restore sh Purpose Restore database from backup files Interactive backup file selection Safety confirmation prompts Supports both development and production Handles compressed backup files Usage scripts restore sh lists available backups scripts restore sh backup_file sql gz scripts restore sh prod backup_file sql gz verify_local_db sh Purpose Verify local PostgreSQL database integrity Tests database connection Verifies table count and structure Checks data integrity and relationships Tests foreign key constraints Validates indexes and unique constraints Usage scripts verify_local_db sh Production Scripts deploy sh Purpose Deploy EPSM to production environment Validates production environment variables Creates automatic backup before deployment Deploys using production Docker Compose Runs migrations and collects static files Performs health checks Usage scripts deploy sh Quick Reference Task Command Start development scripts start sh Stop all services scripts stop sh Check service status scripts status sh Run tests scripts test sh Backup database scripts backup sh Restore database scripts restore sh Verify local DB scripts verify_local_db sh Deploy to production scripts deploy sh Script Dependencies All scripts are designed to be run from the project root directory and expect Docker and Docker Compose installed env file configured created from env example if missing Proper directory structure with frontend backend and configuration files Cleanup Summary The following redundant scripts were removed during organization start epsm sh duplicate of start sh with unnecessary complexity stop epsm sh duplicate of stop sh with extra overhead The script status epsm sh was renamed to status sh for consistency Best Practices 1 Always run scripts from project root scripts script_name sh 2 Check status before starting Use scripts status sh to see current state 3 Stop cleanly Always use scripts stop sh rather than docker compose down 4 Regular backups Run scripts backup sh before major changes 5 Test after changes Use scripts test sh to validate functionality This clean script structure eliminates redundancy while providing all essential functionality for development testing backup and deployment workflows Recent updates development The scripts start sh script was enhanced to streamline the developer workflow Notable behaviors added Checks whether Docker is running and attempts to start Docker Desktop on macOS if not available Creates a local env from env example when none exists and prompts the user to edit or continue Stops any existing containers pulls latest third party images and builds starts services Waits for the database to become ready using pg_isready before proceeding Ensures a dedicated results database and role exist defaults epsm_results epsm_results_user in the Docker Compose environment idempotent creation Runs Django migrations for both the default DB and the results_db if configured via env vars Creates a default Django superuser admin admin123 if one does not already exist Prints helpful service status URLs and quick commands at the end of the run These additions make the development start process more robust and reduce manual setup steps"
    },
    {
      "path": "README.md",
      "url": "/README.md",
      "title": "Docs README",
      "content": "Publishing docs with a Jekyll theme title Docs README layout default This repository uses a Jekyll style docs site located in the docs folder The current Jekyll configuration is in docs _config yml and sets the minima theme by default Goal Serve the contents of docs as a GitHub Pages site using a Jekyll theme no MkDocs needed Publish via GitHub Pages recommended for Jekyll 1 On GitHub open the repository Settings Pages 2 Under Build and deployment set the Source to Branch main Folder docs 3 Save GitHub Pages will build the site using Jekyll and the configuration in docs _config yml Notes Do NOT add a nojekyll file if you want GitHub to run Jekyll and apply the minima theme If you publish to a subpath e g project pages set baseurl in docs _config yml and push changes Local preview Jekyll If you want to preview the site locally with the same Jekyll theme GitHub Pages uses run Jekyll locally Prerequisites Ruby 2 7 recommended Bundler Typical steps If you prefer not to use bundler you can install jekyll and minima globally with gem install jekyll minima and run jekyll serve macOS notes if bundle install fails If bundle install or gem install fails on macOS you may need to install a supported Ruby and make sure gem can install executables Recommended steps using Homebrew If you prefer not to change system Ruby consider using rbenv or asdf to manage a project Ruby installation Customizing the theme Edit docs _config yml to change title description baseurl or theme Add layout includes or custom CSS under docs _layouts docs _includes or docs assets as needed Notes about the existing GitHub Action There is an existing workflow at github workflows publish docs yml that runs mkdocs build That workflow is for MkDocs and is unrelated to Jekyll You can Leave it in place harmless but it will fail until a mkdocs yml exists If you won t use MkDocs consider removing or disabling that workflow to avoid confusion Or update the workflow to deploy the static site output if you switch to an automated build deploy flow instead of serving docs directly If you later want MkDocs instead Move or copy markdown files into the docs folder MkDocs also defaults to docs Add a mkdocs yml at repo root and the workflow will be able to build and publish the generated site Note MkDocs will produce a _site or site directory do not commit that output Quick checklist to go live now Confirm docs _config yml has desired title and baseurl In GitHub Settings Pages set Source main docs Optional Add CNAME in docs for a custom domain That s it if you d like I can remove or rename the MkDocs workflow so there is no confusion and or add a short CI workflow that simply validates jekyll build optional or help customize the minima theme If you want me to make changes now tell me which of the 3 options above you want remove MkDocs workflow add a small Jekyll CI check or customize the theme and I ll implement it Migration notes automated reorg The docs site was reorganized to provide a cleaner sidebar and landing page index md was simplified to a concise landing page The _sidebar md and _layouts default html were updated to show a left hand sidebar and simplified header assets css site css was updated to a modern responsive styleset The old docs folder was backed up to docs backup at the repository root before these changes If you d like any of the moved or removed pages restored or reorganized differently I can revert specific files from docs backup and integrate them into the new IA"
    },
    {
      "path": "GETTING_STARTED.md",
      "url": "/GETTING_STARTED.md",
      "title": "Getting Started",
      "content": "Getting Started with EPSM title Getting Started layout default This comprehensive guide will help you set up and run the Energy Performance Simulation Manager EPSM on your local machine Prerequisites Required Software Docker Desktop Version 24 x or later Download for macOS Download for Windows Download for Linux Git For cloning the repository Text Editor VS Code Sublime Text or similar System Requirements RAM 4GB minimum 8GB recommended Storage 10GB free space Network Internet connection for Docker image downloads Installation 1 Clone the Repository You should see directories like frontend backend scripts etc 2 Environment Configuration Default development values work out of the box but you can customize 3 Start the Application The script will Pull and build Docker images Start PostgreSQL database Run Django migrations Start the Django backend Start the React frontend Create default admin user Notes about scripts start sh enhancements It now checks whether Docker is running and will attempt to launch Docker Desktop on macOS if Docker is not available If a env file is missing the script creates one from env example and prompts you to edit or continue with defaults The script waits for the database to be ready before running migrations It also ensures a results database and role exist defaults epsm_results epsm_results_user and runs results specific migrations when configured A default Django superuser admin admin123 is created automatically if it does not exist 4 Verify Installation Open your browser and navigate to Frontend http localhost 5173 Backend API http localhost 8000 Django Admin http localhost 8000 admin Default login credentials Username admin Password admin123 Development Workflow Daily Development Making Changes Frontend Development Files are in frontend src Hot Module Replacement HMR enabled Changes auto reload in browser TypeScript compilation on the fly Backend Development Files are in backend Django auto reloads on file changes Database changes require migrations Database Access Testing Run Tests Manual Testing 1 Authentication Login at http localhost 5173 2 API Test endpoints at http localhost 8000 api 3 Database Check data via Django admin 4 File Upload Try uploading IDF files 5 Simulations Create and run test simulations Project Structure Troubleshooting Common Issues Port Conflicts Docker Issues Database Connection Frontend Build Issues Backend Python Issues Getting Help 1 Check logs docker compose logs service 2 Verify services scripts status sh 3 Reset everything docker compose down v scripts start sh 4 Check documentation Browse the docs directory 5 GitHub Issues Create an issue with logs and error details Next Steps Once you have EPSM running 1 Explore the Interface Navigate through the web application 2 Upload Test Files Try uploading sample IDF and EPW files 3 Run Simulations Create and execute test simulations 4 Check API Docs Visit http localhost 8000 api docs 5 Read Architecture Review docs ARCHITECTURE md 6 Development Guide Check docs DEVELOPMENT md Contributing 1 Fork the repository 2 Create a feature branch git checkout b feature name 3 Make your changes 4 Run tests scripts test sh 5 Commit changes git commit m Description 6 Push to branch git push origin feature name 7 Create a Pull Request Support Documentation Check the docs folder GitHub Issues https github com snjsomnath epsm issues Email sanjay somanath chalmers se"
    },
    {
      "path": "DEPLOYMENT.md",
      "url": "/DEPLOYMENT.md",
      "title": "Deployment Guide",
      "content": "EPSM Deployment Guide title Deployment Guide layout default Overview This guide covers deploying the EPSM Energy Performance Simulation Manager application using Docker containers The application consists of three main services Frontend React TypeScript Vite Backend Django PostgreSQL Redis Database PostgreSQL with materials data Architecture Prerequisites Docker Engine 20 10 Docker Compose 2 0 Git 4GB RAM 10GB disk space Quick Start Development 1 Clone the repository 2 Configure environment 3 Start the application 4 Access the application Frontend http localhost 5173 Backend API http localhost 8000 Django Admin http localhost 8000 admin admin admin123 Production Deployment 1 Server Preparation 2 Application Deployment 3 Environment Configuration Required Production Variables 4 SSL Configuration Database Management Backup Database Recent development updates The development scripts start sh has been improved to make onboarding easier for new developers and streamline local environment setup Verifies Docker is running and attempts to start Docker Desktop on macOS when necessary Creates env from env example if missing and prompts to edit or continue with defaults Waits for the database to be ready before running migrations Ensures a results database and role exist in the Docker Compose environment defaults epsm_results epsm_results_user and runs results DB migrations when configured Creates a default Django superuser admin admin123 automatically if absent These changes target the development flow production deployment should continue to rely on explicit provisioning and secure environment variables as documented elsewhere in this guide Restore Database Manual Database Access Monitoring Maintenance View Logs Service Health Checks Performance Monitoring Scaling Horizontal Scaling Vertical Scaling Troubleshooting Common Issues 1 Port conflicts 2 Database connection issues 3 Frontend build issues 4 Permission issues Debug Mode Security Considerations 1 Change default passwords 2 Use strong secret keys 3 Enable SSL TLS in production 4 Configure firewall rules 5 Regular security updates 6 Monitor access logs Updates Maintenance Update Application Update Dependencies Support For issues and questions Check logs docker compose logs f Review health checks Consult troubleshooting section Create GitHub issue with logs and configuration details"
    },
    {
      "path": "index.md",
      "url": "/index.md",
      "title": "EPSM â€” Energy Performance Simulation Manager",
      "content": "EPSM Energy Performance Simulation Manager concise documentation hub for developers and operators EPSM helps manage and run EnergyPlus simulations inside containers Start below Quick Start Getting Started Setup Local Development Development Guide Developer Workflow API Reference API Documentation Key Guides Architecture System Overview Deployment Production Guide Results DB Results DB Setup For full details use the sidebar to navigate the docs If you re updating docs or moving pages see DOCS_IA md in this folder for the migration plan"
    },
    {
      "path": "CONTRIBUTING.md",
      "url": "/CONTRIBUTING.md",
      "title": "Contributing",
      "content": "Contributing to EPSM Thanks for considering contributing to EPSM Please follow the process below 1 Fork the repository 2 Create a descriptive branch name for your change 3 Commit with clear messages and add tests where appropriate 4 Open a pull request and reference any related issues Be sure to run tests and linting before submitting a PR See DEVELOPMENT md for details on the developer workflow"
    },
    {
      "path": "_sidebar.md",
      "url": "/_sidebar.md",
      "title": "_sidebar",
      "content": "Documentation Home index md Getting Started GETTING_STARTED md Guides Development DEVELOPMENT md Deployment DEPLOYMENT md Results DB Setup RESULTS_DB_SETUP md Scripts Utilities SCRIPTS md API Reference API md Architecture ARCHITECTURE md Contributing CONTRIBUTING md Project PROJECT_README md License LICENSE md"
    },
    {
      "path": "PROJECT_README.md",
      "url": "/PROJECT_README.md",
      "title": "Project README",
      "content": "EPSM Energy Performance Simulation Manager title Project README layout default A modern containerized web application for managing building energy performance simulations using EnergyPlus Developed at Chalmers University of Technology EPSM empowers building owners researchers and engineers to explore and evaluate energy renovation strategies across large building stocks quickly transparently and at low cost Quick Start Prerequisites Docker 24 x with Docker Compose 4GB RAM 10GB disk space Git Development Setup Project Structure Project Structure Architecture Frontend React 18 TypeScript 5 9 Vite 5 Tailwind CSS Material UI Backend Django 3 2 Django REST Framework PostgreSQL 15 Redis 7 Infrastructure Docker Compose Nginx production WebSocket support Simulation EnergyPlus containerized via NREL Docker image Development Hot reload containerized services automated setup Documentation Development Guide Setup and development workflow Deployment Guide Production deployment Architecture Guide System architecture API Documentation REST API docs Features Interactive Component Database Create and manage materials constructions and construction sets Track environmental impact GWP and cost metrics Version control and change tracking Real time collaboration support Baseline Model Management Upload and parse IDF files Extract geometry and schedules Run baseline simulations Automatic component detection Scenario Builder Create renovation scenarios Define parameter combinations Estimate simulation times Track scenario versions Batch Simulation Runner Parallel simulation execution Real time progress monitoring Resource usage tracking Error handling and recovery Results Analysis Interactive visualization Energy savings comparison Cost benefit analysis Export to various formats Tech Stack Frontend Framework React 18 with TypeScript 5 9 Build Tool Vite 5 UI Components Material UI mui material 5 15 Styling Tailwind CSS 3 4 Charts Chart js Recharts Icons Lucide React HTTP Client Axios Development Hot Module Replacement HMR Backend Framework Django 3 2 with Django REST Framework Language Python 3 11 Database PostgreSQL 15 Caching Redis 7 Alpine WebSockets Django Channels Daphne File Processing eppy EnergyPlus lxml Authentication Django sessions JWT Infrastructure Containerization Docker Compose Development Hot reload for both frontend and backend Database PostgreSQL with persistent volumes Caching Redis for sessions and caching Simulation EnergyPlus via Docker containers Reverse Proxy Nginx production Project Structure Getting Started Prerequisites Node js v18 recommended Python 3 8 EnergyPlus installed PostgreSQL optional for local development Installation 1 Clone the repository 2 Install frontend dependencies 3 Set up environment variables 4 Install backend dependencies 5 Run database migrations Development 1 Start the frontend development server 2 Start the Django backend 3 Access the application at http localhost 5173 Production Deployment 1 Build the frontend 2 Configure your web server e g Nginx to serve the static files from dist 3 Set up the Django backend with Gunicorn and Nginx 4 Configure environment variables for production Security All database access is controlled through Django ORM and permissions Authentication handled by Django with JWT tokens CORS configured for production domains only Rate limiting on API endpoints Input validation and sanitization Regular security audits Contributing 1 Fork the repository 2 Create a feature branch 3 Make your changes 4 Run tests 5 Submit a pull request Please read CONTRIBUTING md for details on our code of conduct and development process License This project is licensed under the MIT License see the LICENSE md file for details Acknowledgments This project is funded by the Swedish Energy Agency under Project ID P2024 04053 Partners Lindholmen Science Park AB Sinom AB Stiftelsen Chalmers Industriteknik Team Lead Developer Sanjay Somanath Principal Investigator Alexander Hollberg Team Members Yinan Yu Sanjay Somanath Contact For questions and support please contact Sanjay Somanath Lead Developer Email sanjay somanath chalmers se"
    },
    {
      "path": "DEVELOPMENT.md",
      "url": "/DEVELOPMENT.md",
      "title": "Development Guide",
      "content": "EPSM Development Guide title Development Guide layout default Complete development environment setup and workflow guide for the Energy Performance Simulation Manager EPSM Quick Start One Command Startup This script will Start Docker services PostgreSQL Django backend React frontend Redis Run database migrations automatically Create default admin user admin admin123 Display service status and URLs One Command Shutdown Check Status Service URLs Frontend http localhost 5173 React Vite dev server Backend API http localhost 8000 Django REST API Django Admin http localhost 8000 admin Database localhost 5432 PostgreSQL Redis localhost 6379 Caching Default Credentials Admin User admin admin123 Database epsm_user epsm_secure_password Architecture Overview Frontend React TypeScript Vite Port 5173 Technology React 18 TypeScript 5 9 Vite 5 Material UI Tailwind CSS Features Hot Module Replacement TypeScript compilation component development Location frontend directory Backend Django REST Framework Port 8000 Technology Django 3 2 Django REST Framework Python 3 11 Features REST API WebSocket support file processing EnergyPlus integration Location backend directory Database PostgreSQL Port 5432 Technology PostgreSQL 15 in Docker container Features Persistent data storage materials database simulation tracking Location database directory Caching Redis Port 6379 Technology Redis 7 Alpine Features Session storage API caching real time updates Usage Automatic via Django configuration Development Workflow Starting Development Making Changes Frontend Development frontend Edit files in frontend src Changes automatically reload via Hot Module Replacement HMR TypeScript compilation happens automatically Tailwind CSS rebuilds on change Backend Development backend Edit files in backend Django auto reloads on Python file changes For model changes create and run migrations Database Development Access PostgreSQL directly Common SQL commands Testing Run All Tests Backend Tests Only Frontend Tests Only Manual API Testing Docker Configuration Services backend Django application with eppy IDF parsing db PostgreSQL database with persistent volumes frontend Vite development server started separately Volumes postgres_data Database persistence media_files Uploaded IDF EPW files and simulation results Networks default Bridge network for inter service communication Database Schema Core Tables auth_user Django user authentication simulation_runs Simulation metadata and status simulation_files File uploads and references simulation_results Simulation outputs and metrics simulation_zones Zone specific results simulation_energy_uses Energy consumption breakdown Legacy Tables from previous data migration materials Material definitions constructions Construction assemblies construction_sets Grouped constructions Troubleshooting Services Not Starting Database Connection Issues Frontend Build Issues Backend Python Issues Logging Application Logs Backend docker compose logs backend Database docker compose logs db Frontend Console output in frontend terminal Simulation Logs EnergyPlus Stored in simulation result directories Django Application logs show simulation start completion Database Simulation status tracked in simulation_runs table Testing API Testing Frontend Testing Navigate to http localhost 5173 Login with provided credentials Upload IDF files and test parsing Run simulations through the UI Security Notes Development Environment CSRF protection enabled but configured for development CORS enabled for frontend backend communication Debug mode enabled for detailed error messages Production Considerations Change default passwords Disable debug mode Configure proper CORS origins Set up SSL TLS certificates Use environment variables for secrets Additional Resources Django Documentation https docs djangoproject com React Documentation https react dev EnergyPlus Documentation https energyplus net documentation Eppy Documentation https eppy readthedocs io Docker Compose https docs docker com compose"
    },
    {
      "path": "ORGANIZATION.md",
      "url": "/ORGANIZATION.md",
      "title": "Organization",
      "content": "Repository Organization title Organization layout default This document describes the clean organization structure implemented for the EPSM repository Directory Structure Configuration Files Configuration files are now organized in the configs directory but are symlinked to the root directory for tool compatibility tsconfig json configs tsconfig json vite config ts configs vite config ts tailwind config js configs tailwind config js postcss config js configs postcss config js eslint config js configs eslint config js This approach keeps the root directory clean while maintaining compatibility with build tools that expect configuration files in the root Changes Made 1 Test Files All test_ and test files moved to tests directory 2 Documentation All md files moved to docs directory 3 Configuration All config files moved to configs with symlinks in root 4 Scripts All sh files moved to scripts directory 5 Database Migrations Consolidated under database migrations 6 Cleanup Removed temporary files log cookies txt Benefits Cleaner Root Essential files only in root directory Organized Structure Related files grouped logically Tool Compatibility Symlinks maintain tool functionality Better Navigation Easier to find specific types of files Reduced Clutter Temporary and development files properly organized Usage All existing commands and tools should continue to work as before due to the symlink approach The organization improves maintainability without breaking existing workflows"
    }
  ]
}